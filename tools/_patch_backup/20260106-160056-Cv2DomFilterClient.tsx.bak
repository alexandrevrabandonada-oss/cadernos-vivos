"use client";

import { useEffect, useMemo, useState } from "react";

type Stats = { total: number; shown: number };

function foldText(input: unknown): string {
  const raw = input == null ? "" : String(input);
  const lower = raw.toLowerCase();
  try {
    return lower.normalize("NFD").replace(/[\\u0300-\\u036f]/g, "");
  } catch {
    return lower;
  }
}

async function copyToClipboard(text: string): Promise<boolean> {
  try {
    if (navigator.clipboard && typeof navigator.clipboard.writeText === "function") {
      await navigator.clipboard.writeText(text);
      return true;
    }
  } catch {
    // ignore
  }
  try {
    const ta = document.createElement("textarea");
    ta.value = text;
    ta.setAttribute("readonly", "");
    ta.style.position = "fixed";
    ta.style.left = "-9999px";
    ta.style.top = "0";
    document.body.appendChild(ta);
    ta.select();
    const ok = document.execCommand("copy");
    document.body.removeChild(ta);
    return ok;
  } catch {
    return false;
  }
}

function uniqByRef<T extends object>(arr: T[]): T[] {
  const seen = new Set<T>();
  const out: T[] = [];
  for (const x of arr) {
    if (!seen.has(x)) {
      seen.add(x);
      out.push(x);
    }
  }
  return out;
}

function findItemRoot(a: HTMLAnchorElement, scope: HTMLElement): HTMLElement {
  const li = a.closest("li");
  if (li && scope.contains(li)) return li as HTMLElement;
  const art = a.closest("article");
  if (art && scope.contains(art)) return art as HTMLElement;
  const sec = a.closest("section");
  if (sec && scope.contains(sec)) return sec as HTMLElement;
  const div = a.closest("div");
  if (div && scope.contains(div)) return div as HTMLElement;
  return a;
}

function getScope(rootId: string): HTMLElement | null {
  const el = document.getElementById(rootId);
  return el ? (el as HTMLElement) : null;
}

export function Cv2DomFilterClient(props: {
  rootId: string;
  label?: string;
  placeholder?: string;
}) {
  const [q, setQ] = useState<string>("");
  const [stats, setStats] = useState<Stats>({ total: 0, shown: 0 });
  const [toast, setToast] = useState<string>("");

  const label = props.label || "Filtrar provas";
  const placeholder = props.placeholder || "Digite para filtrar…";

  const qFold = useMemo(() => foldText(q).trim(), [q]);

  useEffect(() => {
    const scope = getScope(props.rootId);
    if (!scope) return;

    // evita filtrar o próprio UI
    const skip = "[data-cv2-filter-ui=1]";

    const anchors = Array.from(scope.querySelectorAll<HTMLAnchorElement>("a[href]"));
    const roots = anchors.map((a) => findItemRoot(a, scope));
    const items = uniqByRef(roots).filter((el) => !el.closest(skip));

    let shown = 0;
    for (const el of items) {
      const hay = foldText(el.textContent || "");
      const ok = qFold.length === 0 ? true : hay.includes(qFold);
      // eslint-disable-next-line react-hooks/immutability
      if (ok) el.removeAttribute("hidden");
      // eslint-disable-next-line react-hooks/immutability
      if (!ok) el.setAttribute("hidden", "");
      if (ok) shown += 1;
    }
    setStats({ total: items.length, shown });
  }, [props.rootId, qFold]);

  function collectVisibleLinks(): Array<{ href: string; text: string }> {
    const scope = getScope(props.rootId);
    if (!scope) return [];
    const links: Array<{ href: string; text: string }> = [];
    const seen = new Set<string>();
    const skip = "[data-cv2-filter-ui=1]";
    const anchors = Array.from(scope.querySelectorAll<HTMLAnchorElement>("a[href]"));
    for (const a of anchors) {
      if (a.closest(skip)) continue;
      const item = findItemRoot(a, scope);
      if (item.hasAttribute("hidden")) continue;
      const href = a.getAttribute("href") || "";
      if (!href || href.startsWith("#")) continue;
      if (seen.has(href)) continue;
      seen.add(href);
      const text = (a.textContent || "").replace(/\\s+/g, " ").trim();
      links.push({ href, text });
    }
    return links;
  }

  async function doCopy(kind: "plain" | "md") {
    const links = collectVisibleLinks();
    const text = kind === "plain"
      ? links.map((l) => l.href).join("\\n")
      : links.map((l) => "- [" + (l.text || l.href) + "](" + l.href + ")").join("\\n");
    const ok = await copyToClipboard(text);
    setToast(ok ? "Copiado!" : "Falhou ao copiar");
    window.setTimeout(() => setToast(""), 1200);
  }

  return (
    <div className="cv2-domfilter" data-cv2-filter-ui="1">
      <div className="cv2-domfilter__row">
        <label className="cv2-domfilter__label">
          <span className="cv2-domfilter__labelText">{label}</span>
          <input
            className="cv2-domfilter__input"
            value={q}
            onChange={(e) => setQ(e.target.value)}
            placeholder={placeholder}
            aria-label={label}
          />
        </label>
        <button type="button" className="cv2-domfilter__btn" onClick={() => setQ("")} disabled={q.length === 0}>
          Limpar
        </button>
        <button type="button" className="cv2-domfilter__btn" onClick={() => void doCopy("plain")}>
          Copiar links
        </button>
        <button type="button" className="cv2-domfilter__btn" onClick={() => void doCopy("md")}>
          Copiar MD
        </button>
      </div>
      <div className="cv2-domfilter__meta" aria-live="polite">
        <span className="cv2-domfilter__count">{stats.shown}/{stats.total}</span>
        {toast ? <span className="cv2-domfilter__toast">{toast}</span> : null}
      </div>
    </div>
  );
}