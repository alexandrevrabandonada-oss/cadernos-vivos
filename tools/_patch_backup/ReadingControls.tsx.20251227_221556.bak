"use client";

import React, { useEffect, useMemo, useRef, useState } from "react";

type Prefs = { reading: boolean; scale: number };

function safeParsePrefs(): Prefs {
  if (typeof window === "undefined") return { reading: false, scale: 1 };
  try {
    const raw = window.localStorage.getItem("cv_reading_prefs");
    if (!raw) return { reading: false, scale: 1 };
    const obj = JSON.parse(raw) as { reading?: unknown; scale?: unknown };
    const reading = obj.reading === true;
    const scale = (typeof obj.scale === "number" && obj.scale >= 0.9 && obj.scale <= 1.6) ? obj.scale : 1;
    return { reading, scale };
  } catch {
    return { reading: false, scale: 1 };
  }
}

function applyPrefs(p: Prefs) {
  if (typeof document === "undefined") return;
  const root = document.documentElement;
  root.classList.toggle("cv-reading", p.reading);
  root.style.setProperty("--cv-font-scale", String(p.scale));
}

export default function ReadingControls() {
  const [mounted, setMounted] = useState(false);
  // IMPORTANT: estado inicial fixo para bater server/client (evita hydration mismatch)
  const [reading, setReading] = useState(false);
  const [scale, setScale] = useState(1);
  const [speaking, setSpeaking] = useState(false);
  const utterRef = useRef<SpeechSynthesisUtterance | null>(null);

  useEffect(() => {
    setMounted(true);
    const p = safeParsePrefs();
    setReading(p.reading);
    setScale(p.scale);
  }, []);

  useEffect(() => {
    if (!mounted) return;
    const p: Prefs = { reading, scale };
    applyPrefs(p);
    try { window.localStorage.setItem("cv_reading_prefs", JSON.stringify(p)); } catch {}
  }, [mounted, reading, scale]);

  const canTts = useMemo(() => (typeof window !== "undefined" && "speechSynthesis" in window), []);

  function pickText(): string {
    if (typeof document === "undefined") return "";
    const main = document.querySelector("main");
    const t = main ? (main as HTMLElement).innerText : document.body.innerText;
    return (t || "").trim();
  }

  function stopTts() {
    if (typeof window === "undefined") return;
    try { window.speechSynthesis.cancel(); } catch {}
    utterRef.current = null;
    setSpeaking(false);
  }

  function startTts() {
    if (!canTts) return;
    const text = pickText();
    if (!text) return;
    stopTts();
    const u = new SpeechSynthesisUtterance(text);
    utterRef.current = u;
    u.onend = () => { setSpeaking(false); utterRef.current = null; };
    u.onerror = () => { setSpeaking(false); utterRef.current = null; };
    setSpeaking(true);
    window.speechSynthesis.speak(u);
  }

  return (
    <section className="card p-4 flex flex-wrap gap-2 items-center" aria-label="Controles de leitura">
      <button
        type="button"
        className="card px-3 py-2 hover:bg-white/10 transition"
        aria-pressed={reading}
        onClick={() => setReading(v => !v)}
      >
        {reading ? "Leitura: ON" : "Leitura: OFF"}
      </button>

      <label className="text-sm muted flex items-center gap-2" aria-label="Tamanho do texto">
        <span>A</span>
        <input
          type="range"
          min={0.9}
          max={1.6}
          step={0.05}
          value={scale}
          onChange={(e) => setScale(Number(e.target.value))}
        />
        <span>A+</span>
      </label>

      <div className="flex gap-2 items-center">
        <button
          type="button"
          className="card px-3 py-2 hover:bg-white/10 transition"
          onClick={() => (speaking ? stopTts() : startTts())}
          disabled={!canTts}
          aria-pressed={speaking}
        >
          {canTts ? (speaking ? "Parar voz" : "Ouvir") : "Voz indispon√≠vel"}
        </button>
      </div>
    </section>
  );
}
