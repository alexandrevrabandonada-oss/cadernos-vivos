"use client";

import React, { useEffect, useMemo, useRef, useState } from "react";
import { useEffect, useState } from "react";

type Prefs = { reading: boolean; scale: number };
const KEY = "cv:prefs";

function clamp(n: number, a: number, b: number) { return Math.max(a, Math.min(b, n)); }

function safeParsePrefs(): Prefs {
  try {
    if (typeof window === "undefined") return { reading: false, scale: 1 };
    const raw = window.localStorage.getItem(KEY);
    if (!raw) return { reading: false, scale: 1 };
    const j = JSON.parse(raw) as unknown;
    const o = (j && typeof j === "object") ? (j as Record<string, unknown>) : null;
    const reading = o && typeof o.reading === "boolean" ? o.reading : false;
    const scale0 = o && typeof o.scale === "number" ? o.scale : 1;
    const scale = clamp(scale0, 0.85, 1.25);
    return { reading, scale };
  } catch {
    return { reading: false, scale: 1 };
  }
}

function applyToDom(p: Prefs) {
  if (typeof document === "undefined") return;
  const root = document.documentElement;
  root.dataset.cvReading = p.reading ? "1" : "0";
  root.style.setProperty("--cv-scale", String(p.scale));
}

function savePrefs(p: Prefs) {
  try {
    if (typeof window === "undefined") return;
    window.localStorage.setItem(KEY, JSON.stringify(p));
  } catch {}
}

function pickReadableText(): string {
  try {
    if (typeof document === "undefined") return "";
    const el = document.querySelector(".cv-md") as HTMLElement | null;
    const base = el || (document.querySelector("main") as HTMLElement | null);
    const txt = base ? (base.innerText || "") : "";
    return txt.trim();
  } catch {
    return "";
  }
}

export default function ReadingControls() {
  const [hydrated, setHydrated] = useState(false);
  useEffect(() => { setHydrated(true); }, []);
  
  // SSR estável: começa sempre igual (evita mismatch).
  const [ready, setReady] = useState(false);
  const [prefs, setPrefs] = useState<Prefs>({ reading: false, scale: 1 });
  const canSpeak = useMemo(() => hydrated && "speechSynthesis" in window, []);
  const speakingRef = useRef(false);

  // carrega prefs no client sem disparar lint "setState in effect" diretamente
  useEffect(() => {
    const id = setTimeout(() => {
      const p = safeParsePrefs();
      setPrefs(p);
      applyToDom(p);
      setReady(true);
    }, 0);
    return () => clearTimeout(id);
  }, []);

  const onToggleReading = () => {
    const next: Prefs = { ...prefs, reading: !prefs.reading };
    setPrefs(next);
    applyToDom(next);
    savePrefs(next);
  };

  const onScale = (delta: number) => {
    const next: Prefs = { ...prefs, scale: clamp(prefs.scale + delta, 0.85, 1.25) };
    setPrefs(next);
    applyToDom(next);
    savePrefs(next);
  };

  const onSpeak = () => {
    if (!canSpeak) return;
    const synth = window.speechSynthesis;
    if (speakingRef.current) {
      try { synth.cancel(); } catch {}
      speakingRef.current = false;
      return;
    }
    const txt = pickReadableText();
    if (!txt) return;
    try {
      synth.cancel();
      const u = new SpeechSynthesisUtterance(txt);
      u.lang = "pt-BR";
      u.onend = () => { speakingRef.current = false; };
      u.onerror = () => { speakingRef.current = false; };
      speakingRef.current = true;
      synth.speak(u);
    } catch {
      speakingRef.current = false;
    }
  };

  // Enquanto não está ready, mantém aria-pressed consistente com SSR.
  const pressed = ready ? prefs.reading : false;

  return (
    <section className="card p-4 flex flex-wrap items-center gap-2" aria-label="Controles de leitura">
      <button
        type="button"
        className="card px-3 py-2 hover:bg-white/10 transition"
        aria-pressed={pressed}
        onClick={onToggleReading}
      >
        {pressed ? "Modo leitura: ON" : "Modo leitura: OFF"}
      </button>

      <div className="flex items-center gap-2">
        <button type="button" className="card px-3 py-2 hover:bg-white/10 transition" onClick={() => onScale(-0.05)} aria-label="Diminuir tamanho do texto">
          A-
        </button>
        <div className="text-sm opacity-80" aria-label="Escala de texto">
          {Math.round((prefs.scale || 1) * 100)}%
        </div>
        <button type="button" className="card px-3 py-2 hover:bg-white/10 transition" onClick={() => onScale(0.05)} aria-label="Aumentar tamanho do texto">
          A+
        </button>
      </div>

      <button
        type="button"
        className="card px-3 py-2 hover:bg-white/10 transition"
        onClick={onSpeak}
        disabled={!canSpeak}
        aria-label="Ouvir a página"
      >
        {canSpeak ? "Ouvir" : "Ouvir (indisponível)"}
      </button>
    </section>
  );
}